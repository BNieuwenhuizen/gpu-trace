#!/bin/bash

set -e
set -o pipefail
set -o nounset

function pVerbose () {
    if [ "${VERBOSE}" == "1" ]; then
        echo $@
    fi
}

function pErr () {
    local msg="$@"

    if [ "${GUI}" == "1" ]; then
        notify-send $(basename $0) "$msg" --icon=dialog-error
    fi

    echo -e "$msg"
}

function die () {
    if [ $# -ne 0 ]; then
        pErr $@
    fi
    exit 1
}

function pushTrap () {
    local newHandler=$1; shift;
    local signals=$@;

    for signal in $signals; do
        local currHandler=$(trap -p $signal)
        currHandler=${currHandler#*\'}
        currHandler=${currHandler%\' $signal}

        trap "$newHandler; $currHandler" $signal
    done
}

function waitForProcess () {
    local pid="$1"; shift;
    local pidFile="/proc/$pid"

    if [ ! -e ${pidFile} ]; then
        pErr "Could not find process: $pid. Did it already exit?"
        return
    fi

    pVerbose "Waiting for process: $pid"

    # Can't do event based wait for PID unless it is a child PID
    # We are most likely interested in an external PID
    while [ -e /proc/$pid ]; do
        sleep ${PID_POLL_PRECISION};
    done

    pVerbose "Finished waiting for process: $pid"
}

function runAsRoot() {
    if [ "${GUI}" == "0" ]; then
        sudo "$@"
        return
    fi

    # Prefer pkexec as it automatically detects CLI fallback
    if [ -e "$(which pkexec)" ]; then
        pkexec "$@"
        return
    fi

    if [ -e "$(which gksudo)" ]; then
        gksudo "$@"
        return
    fi

    die "No suitable GUI sudo helper found, consider installing pkexec or gksu packages"
}

function setSuid () {
    local path="$1"; shift;
    if [ ! -u "$path" ]; then
        pVerbose "Setting $path"
        runAsRoot chmod 4755 "$path"
    fi
}

# Avoid cli defaults EDITOR and VISUAL since we might be running
# in a background process
function getDefaultReportEditor () {
    if [ -e "$(which gvim)" ]; then
        echo gvim
        return
    fi

    if [ -e "$(which gedit)" ]; then
        echo gedit
        return
    fi

    if [ -e "$(which kate)" ]; then
        echo gedit
        return
    fi

    pVerbose "Warning: No valid default editor found"
}

# helper variables
UNINIT="UNINITMAGIC"
TMPDIR="$(mktemp -d)"
pushTrap "rm -rf $TMPDIR"

# parameter defaults
VERBOSE=0
EXIT_SIG=2 #SIGINT
SNAPSHOT_SIG=5 #SIGTRAP
PID="${UNINIT}"
PID_POLL_PRECISION="0.1"
TRACE_OUTPUT="amdgpu.trace"
REPORT=0
GUI=0
REPORT_EDITOR="$(getDefaultReportEditor)"

function printUsage() {
    pErr "Usage: $(basename $0) [options]"
    pErr
    pErr "Options:"
    pErr "    -p, --wait-for-pid <pid>  Trace for the lifetime of <pid>"
    pErr "    -s, --snapshot-signal <n> Snapshot trace when signal <n> is received (default: ${SNAPSHOT_SIG}"
    pErr "    -e, --exit-signal <n>     Trace until signal <n> is received (default: ${EXIT_SIG}"
    pErr "    -r, --report              Open a report in a text editor (default: ${REPORT_EDITOR})"
    pErr "        --editor              Select a custom editor for a report"
    pErr "    -o, --output <path>       Specify output file location"
    pErr "    -g, --gui                 Run in a GUI friendly environment"
    pErr "    -v, --verbose             Verbose Output"
    pErr "    -h, --help                Print this help menu and exit"
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--verbose) VERBOSE=1; shift ;;
        -p|--wait-for-pid) PID=$2; shift 2 ;;
        -s|--snapshot-signal) SNAPSHOT_SIG=$2; shift 2 ;;
        -e|--exit-signal) EXIT_SIG=$2; shift 2 ;;
        -o|--output) TRACE_OUTPUT="$2"; shift 2 ;;
        -g|--gui) GUI=1; shift ;;
        -r|--report) REPORT=1; shift ;;
        --editor) REPORT_EDITOR=$2; shift 2 ;;
        -h|--help) printUsage; exit ;;
        *) echo "Unknown option $1"; printUsage; die;;
    esac
done

startTrace__tracePid=$UNINIT
startTrace__traceFile=$UNINIT
function startTrace () {
    startTrace__traceFile=$TMPDIR/trace-cmd.dat
    trace-cmd record -o $startTrace__traceFile \
        -e "drm:drm_vblank_event"\
        -e "drm:drm_vblank_event_queued"\
        -e "drm:drm_vblank_event_delivered" \
        -e "amdgpu:amdgpu_cs_ioctl" \
        -e "amdgpu:amdgpu_sched_run_job" \
        -e "drm:drm_vblank_event" \
        -e "*fence:*fence_signaled" &
    startTrace__tracePid=$!
    pushTrap "kill -9 $startTrace__tracePid" # minimal chance of PID collision here
    pVerbose "Starting trace-cmd with pid: $startTrace__tracePid"
}

function stopTrace () {
    if [ "${startTrace__tracePid}" == "$UNINIT" \
        -o "${startTrace__traceFile}" == "$UNINIT" ]; then
        die "stopTrace called with no trace started"
    fi

    pVerbose "Stopping trace with pid: $startTrace__tracePid"
    kill -2 $startTrace__tracePid
    waitForProcess $startTrace__tracePid
    trace-cmd report -i $startTrace__traceFile > $TRACE_OUTPUT
}

function processReport () {
    stopTrace

    if [ -x "${REPORT_EDITOR} " ]; then
        die "Invalid report editor: '${REPORT_EDITOR}'"
    fi

    if [ "${REPORT}" == "1" ]; then
        ${REPORT_EDITOR} ${TRACE_OUTPUT}
    fi
}

function setupTraceCmd () {
    local path="$(which trace-cmd)"

    if [ "${path}" == "" ]; then
        die "Could not find required application: trace-cmd"
    fi

    setSuid "$path"
}

setupTraceCmd
pushTrap "processReport; exit" $EXIT_SIG
pushTrap "processReport; startTrace" $SNAPSHOT_SIG
startTrace

if [ "${PID}" != "$UNINIT" ]; then
    waitForProcess $PID
    processReport
else
    sleep inf
fi
