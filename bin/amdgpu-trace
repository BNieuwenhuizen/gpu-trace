#!/bin/bash

set -e
set -o pipefail
set -o nounset

function pVerbose () {
    if [ "${VERBOSE}" == "1" ]; then
        echo $@
    fi
}

function pErr () {
    echo -e $@
}

function die () {
    if [ $# -ne 0 ]; then
        pErr $@
    fi
    exit 1
}

function pushTrap () {
    local newHandler=$1; shift;
    local signals=$@;

    for signal in $signals; do
        local currHandler=$(trap -p $signal)
        currHandler=${currHandler#*\'}
        currHandler=${currHandler%\' $signal}

        trap "$newHandler; $currHandler" $signal
    done
}

function waitForProcess () {
    local pid="$1"; shift;
    local pidFile="/proc/$pid"

    if [ ! -e ${pidFile} ]; then
        pErr "Could not find process: $pid. Did it already exit?"
        return
    fi

    pVerbose "Waiting for process: $pid"

    # Can't do event based wait for PID unless it is a child PID
    # We are most likely interested in an external PID
    while [ -e /proc/$pid ]; do
        sleep ${PID_POLL_PRECISION};
    done

    pVerbose "Finished waiting for process: $pid"
}

# helper variables
UNINIT="UNINITMAGIC"
TMPDIR="$(mktemp -d)"
pushTrap "rm -rf $TMPDIR"

# parameter defaults
VERBOSE=0
PID="${UNINIT}"
PID_POLL_PRECISION="0.01"
TRACE_OUTPUT="amdgpu.trace"
REPORT=0
REPORT_EDITOR="gvim" # Avoid cli defaults EDITOR and VISUAL since we might be running
                     # in a background process

function printUsage() {
    pErr "Usage: $(basename $0) [options]"
    pErr
    pErr "Options:"
    pErr "    -p, --pid <pid>       Trace for the lifetime of <pid>"
    pErr "    -r, --report          Open a report in a text editor (default: ${REPORT_EDITOR})"
    pErr "        --editor          Select a custom editor for a report"
    pErr "    -o, --output <path>   Specify output file location"
    pErr "    -v, --verbose         Verbose Output"
    pErr "    -h, --help            Print this help menu and exit"
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--verbose) VERBOSE=1; shift ;;
        -p|--pid) PID=$2; shift 2 ;;
        -o|--output) TRACE_OUTPUT="$1"; shift 2 ;;
        -r|--report) REPORT=1; shift ;;
        --editor) REPORT_EDITOR=$2; shift 2 ;;
        -h|--help) printUsage; exit ;;
        *) echo "Unknown option $1"; printUsage; die;;
    esac
done

startTrace__tracePid=$UNINIT
startTrace__traceFile=$UNINIT
function startTrace () {
    startTrace__traceFile=$TMPDIR/trace-cmd.dat
    trace-cmd record -o $startTrace__traceFile \
        -p function -l "drm_handle_vblank" -l "drm_wait_vblank" \
        -e "amdgpu:amdgpu_vm_flush" -e "amdgpu:amdgpu_cs_ioctl" \
        -e "amdgpu:amdgpu_sched_run_job" -e "drm:drm_vblank_event" \
        -e "fence:fence_signaled" &
    startTrace__tracePid=$!
    pushTrap "kill -9 $startTrace__tracePid" # minimal chance of PID collision here
    pVerbose "Starting trace-cmd with pid: $startTrace__tracePid"
}

function stopTrace () {
    if [ "${startTrace__tracePid}" == "$UNINIT" \
        -o "${startTrace__traceFile}" == "$UNINIT" ]; then
        die "stopTrace called with no trace started"
    fi

    pVerbose "Stopping trace with pid: $startTrace__tracePid"
    sudo kill -2 $startTrace__tracePid
    waitForProcess $startTrace__tracePid
    trace-cmd report -i $startTrace__traceFile > $TRACE_OUTPUT
}

function doReport () {
    $REPORT_EDITOR $TRACE_OUTPUT
}

startTrace
waitForProcess $PID
stopTrace

if [ "${REPORT}" == "1" ]; then
    doReport
fi
